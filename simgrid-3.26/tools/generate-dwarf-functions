#!/usr/bin/env sh
# Generate files from a given dwarf.h
# Usage: tools/generate-dwarf-functions /usr/include/dwarf.h

HEADER="\
/* Copyright (c) 2014-$(date +%Y). The SimGrid Team.
 * All rights reserved.                                                     */

/* This program is free software; you can redistribute it and/or modify it
 * under the terms of the license (GNU LGPL) which comes with this package. */

/* Warning: autogenerated, do not edit! */

#include <string>
#include <unordered_map>

#include \"src/mc/mc_dwarf.hpp\""

cat - > src/mc/mc_dwarf_tagnames.cpp <<EOF
$HEADER

namespace {
const std::unordered_map<int, const char*> tagname_map = {
    {0x00, "DW_TAG_invalid"},
$(grep DW_TAG_ -- "$1" | sed 's/.*\(DW_TAG_[^ ]*\) = \(0x[0-9a-f]*\).*/    {\2, "\1"},/')
};
}

namespace simgrid {
namespace dwarf {

/** @brief Get the name of a dwarf tag (DW_TAG_*) from its code
 *
 *  @param tag tag code (see the DWARF specification)
 *  @return name of the tag
 */
XBT_PRIVATE
const char *tagname(int tag)
{
  auto name = tagname_map.find(tag);
  return name == tagname_map.end() ? "DW_TAG_unknown" : name->second;
}

}
}
EOF

cat - > src/mc/mc_dwarf_attrnames.cpp << EOF
$HEADER

namespace {
const std::unordered_map<int, const char*> attrname_map = {
$(grep DW_AT_ -- "$1" | sed 's/.*\(DW_AT_[^ ]*\) = \(0x[0-9a-f]*\).*/    {\2, "\1"},/')
};
}

namespace simgrid {
namespace dwarf  {

/** @brief Get the name of an attribute (DW_AT_*) from its code
 *
 *  @param attr attribute code (see the DWARF specification)
 *  @return name of the attribute
 */
XBT_PRIVATE
const char *attrname(int attr)
{
  auto name = attrname_map.find(attr);
  return name == attrname_map.end() ? "DW_AT_unknown" : name->second;
}

}
}
EOF
